#!/usr/bin/env python3
"""
Polymarket Weather Bot - TESTING MODE (Agresivo para acumular datos rÃ¡pido)
API Keys: Tomorrow.io + Weatherbit configuradas
"""

import json
import os
import re
import time
import logging
import requests
import dateparser
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from collections import defaultdict

# === CONFIGURACIÃ“N TESTING AGRESIVO ===

CONFIG = {
    "bankroll": 30.0,
    "min_trade": 1.0,
    "max_trade": 2.0,
    "absolute_max_day": 5,       # â† AUMENTADO: 5 trades/dÃ­a (vs 3)
    "stop_loss_day": 3,          # â† AUMENTADO: Tolerancia 3 pÃ©rdidas
    "min_edge": 0.15,            # â† BAJADO: 15% edge mÃ­nimo (vs 30%)
    "cooldown_hours": 2,         # â† BAJADO: 2h entre trades (vs 4h)
    
    # APIs
    "polymarket_gamma": "https://gamma-api.polymarket.com/markets",
    "tomorrowio_url": "https://api.tomorrow.io/v4/timelines",
    "weatherbit_url": "https://api.weatherbit.io/v2.0/forecast/daily",
    
    # Scheduler mÃ¡s frecuente para testing
    "run_interval_seconds": 1800,  # â† 30 min (vs 1 hora)
    "max_runtime_hours": 24,
    
    # Filtros relajados
    "min_liquidity": 500,        # â† BAJADO: $500 (vs $1000)
    "cities": ["Seattle", "New York", "NYC", "Boston", "Chicago", 
               "Toronto", "Atlanta", "Dallas", "Denver", "London", "Seoul",
               "Miami", "Houston", "Phoenix", "Philadelphia", "San Francisco",
               "Detroit", "Minneapolis", "Portland", "Las Vegas"],  # â† EXPANDIDO
    
    # MÃ¡s keywords para capturar mercados
    "weather_keywords": ["temperature", "high", "low", "Â°f", "Â°c", "degrees",
                        "rain", "snow", "precipitation", "sunny", "cloudy",
                        "storm", "wind", "humidity", "heat", "cold", "freezing",
                        "boiling", "mild", "warm", "chilly", "frost", "drizzle"],
    
    # Archivos
    "state_file": "survival_state.json",
    "positions_file": "positions.json",
    "log_file": "bot.log",
}

# === LOGGING ===

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(CONFIG["log_file"])
    ]
)
logger = logging.getLogger(__name__)

# === ESTRUCTURAS ===

@dataclass
class Position:
    position_id: str
    market_slug: str
    condition_id: str
    question: str
    city: str
    outcome: str
    outcome_index: int
    token_id: str
    side: str
    entry_price: float
    shares: float
    stake: float
    trade_type: str
    edge_at_entry: float
    entry_time: str
    target_date: str
    status: str = "open"
    resolution_price: Optional[float] = None
    pnl: Optional[float] = None
    resolved_at: Optional[str] = None
    pnl_applied: bool = False

# === PERSISTENCIA ===

class StateManager:
    def __init__(self):
        self.state_path = Path(CONFIG["state_file"])
        self.positions_path = Path(CONFIG["positions_file"])
    
    def load_state(self) -> Dict:
        if self.state_path.exists():
            try:
                with open(self.state_path, 'r') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Error cargando estado: {e}")
        
        return {
            "cash": CONFIG["bankroll"],
            "exposed": 0.0,
            "total_trades": 0,
            "wins": 0,
            "losses": 0,
            "today_trades": 0,
            "today_losses": 0,
            "today_wins": 0,
            "last_trade_time": None,
            "consecutive_losses": 0,
            "current_date": datetime.now(timezone.utc).strftime("%Y-%m-%d"),
            "lifetime_pnl": 0.0,
            "max_drawdown": 0.0,
            "peak_bankroll": CONFIG["bankroll"],
        }
    
    def save_state(self, state: Dict):
        tmp = self.state_path.with_suffix('.tmp')
        try:
            with open(tmp, 'w') as f:
                json.dump(state, f, indent=2)
            tmp.replace(self.state_path)
        except Exception as e:
            logger.error(f"Error guardando estado: {e}")
            if tmp.exists():
                tmp.unlink()
    
    def load_positions(self) -> List[Position]:
        if not self.positions_path.exists():
            return []
        
        try:
            with open(self.positions_path, 'r') as f:
                data = json.load(f)
            
            positions = []
            for p in data:
                if "pnl_applied" not in p:
                    p["pnl_applied"] = False
                if "outcome_index" not in p:
                    p["outcome_index"] = 0
                positions.append(Position(**p))
            
            return positions
        except Exception as e:
            logger.error(f"Error cargando posiciones: {e}")
            return []
    
    def save_positions(self, positions: List[Position]):
        data = [asdict(p) for p in positions]
        tmp = self.positions_path.with_suffix('.tmp')
        try:
            with open(tmp, 'w') as f:
                json.dump(data, f, indent=2, default=str)
            tmp.replace(self.positions_path)
        except Exception as e:
            logger.error(f"Error guardando posiciones: {e}")

state_mgr = StateManager()

# === RESET DIARIO ===

def check_daily_reset(state: Dict) -> Dict:
    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    
    if state.get("current_date") != today:
        logger.info(f"ğŸŒ… Nuevo dÃ­a: {today}")
        logger.info(f"   Ayer: {state['today_wins']}W/{state['today_losses']}L")
        
        state["current_date"] = today
        state["today_trades"] = 0
        state["today_losses"] = 0
        state["today_wins"] = 0
        state["consecutive_losses"] = 0
    
    return state

# === DRAWDOWN ===

def update_drawdown(state: Dict):
    state["peak_bankroll"] = max(state["peak_bankroll"], state["cash"])
    drawdown = state["peak_bankroll"] - state["cash"]
    state["max_drawdown"] = max(state["max_drawdown"], drawdown)
    return state

# === RESOLUCIÃ“N ===

class ResolutionEngine:
    def __init__(self):
        self.session = requests.Session()
    
    def fetch_market_resolution(self, condition_id: str) -> Optional[Dict]:
        try:
            url = f"{CONFIG['polymarket_gamma']}/{condition_id}"
            resp = self.session.get(url, timeout=10)
            resp.raise_for_status()
            data = resp.json()
            
            return {
                "resolved": data.get("resolved", False),
                "outcome": data.get("outcomeIndex"),
                "resolution_time": data.get("resolutionTime"),
                "question": data.get("question"),
                "outcomes": data.get("outcomes", []),
            }
        except Exception as e:
            logger.error(f"Error fetching resolution: {e}")
            return None
    
    def resolve_position(self, pos: Position, market_data: Dict, state: Dict) -> bool:
        if not market_data or not market_data.get("resolved"):
            return False
        
        if pos.status != "open":
            return False
        
        try:
            winning_index = market_data["outcome"]
            
            if winning_index is None or not isinstance(winning_index, int):
                logger.error(f"Ãndice invÃ¡lido: {winning_index}")
                return False
            
            if pos.outcome_index == winning_index:
                payout = pos.shares * 1.0
                pnl = payout - pos.stake
                status = "won"
                logger.info(f"âœ… GANADA: {pos.market_slug} | +${pnl:.2f}")
            else:
                pnl = -pos.stake
                status = "lost"
                logger.info(f"âŒ PERDIDA: {pos.market_slug} | ${pnl:.2f}")
            
            pos.status = status
            pos.pnl = pnl
            pos.resolved_at = datetime.now(timezone.utc).isoformat()
            pos.resolution_price = 1.0 if status == "won" else 0.0
            
            state["cash"] += pos.stake + pnl
            state["exposed"] -= pos.stake
            state["exposed"] = max(0, state["exposed"])
            state["lifetime_pnl"] += pnl
            
            if status == "won":
                state["wins"] += 1
                state["today_wins"] += 1
                state["consecutive_losses"] = 0
            else:
                state["losses"] += 1
                state["today_losses"] += 1
                state["consecutive_losses"] += 1
            
            state = update_drawdown(state)
            pos.pnl_applied = True
            return True
            
        except Exception as e:
            logger.error(f"Error resolviendo: {e}")
            return False
    
    def check_all_positions(self, positions: List[Position], state: Dict) -> List[Position]:
        resolved_count = 0
        
        for pos in positions:
            if pos.status != "open" or pos.pnl_applied:
                continue
            
            try:
                target = datetime.fromisoformat(pos.target_date.replace('Z', '+00:00'))
                if datetime.now(timezone.utc) < target + timedelta(hours=24):
                    continue
            except:
                continue
            
            market_data = self.fetch_market_resolution(pos.condition_id)
            if not market_data:
                continue
            
            if self.resolve_position(pos, market_data, state):
                resolved_count += 1
        
        if resolved_count > 0:
            logger.info(f"ğŸ¯ {resolved_count} resueltas | Cash: ${state['cash']:.2f}")
        
        return positions

# === WEATHER APIs ===

class WeatherAPI:
    def __init__(self):
        self.keys = {
            "tomorrowio": "RfRDKxiUphzUEYfFcXsDuwBTxBZCrvJ7",
            "weatherbit": "a40d62b402ab45b684656d419ef87ceb"
        }
        self.cache = {}
        self.session = requests.Session()
        
        # EXPANDIDO: MÃ¡s ciudades
        self.city_coords = {
            "seattle": (47.6062, -122.3321),
            "new york": (40.7128, -74.0060),
            "nyc": (40.7128, -74.0060),
            "boston": (42.3601, -71.0589),
            "chicago": (41.8781, -87.6298),
            "toronto": (43.6510, -79.3470),
            "atlanta": (33.7490, -84.3880),
            "dallas": (32.7767, -96.7970),
            "denver": (39.7392, -104.9903),
            "london": (51.5074, -0.1278),
            "seoul": (37.5665, 126.9780),
            "miami": (25.7617, -80.1918),
            "houston": (29.7604, -95.3698),
            "phoenix": (33.4484, -112.0740),
            "philadelphia": (39.9526, -75.1652),
            "san francisco": (37.7749, -122.4194),
            "detroit": (42.3314, -83.0458),
            "minneapolis": (44.9778, -93.2650),
            "portland": (45.5152, -122.6784),
            "las vegas": (36.1699, -115.1398),
        }
        
        self.weatherbit_cities = {
            "london": "London,UK",
            "toronto": "Toronto,CA",
            "seoul": "Seoul,KR",
        }
    
    def get_forecast(self, city: str, target_date: str) -> Optional[Dict]:
        cache_key = f"{city.lower()}_{target_date}"
        
        if cache_key in self.cache:
            cached = self.cache[cache_key]
            if (datetime.now(timezone.utc) - cached["time"]).seconds < 3600:
                return cached["data"]
        
        forecasts = []
        
        if self.keys.get("tomorrowio"):
            try:
                fc = self._fetch_tomorrowio(city, target_date)
                if fc: 
                    forecasts.append(("tomorrowio", fc))
                    logger.info(f"âœ… Tomorrow.io OK: {city}")
            except Exception as e:
                logger.warning(f"Tomorrow.io fallÃ³: {e}")
        
        if len(forecasts) == 0 and self.keys.get("weatherbit"):
            try:
                fc = self._fetch_weatherbit(city, target_date)
                if fc: 
                    forecasts.append(("weatherbit", fc))
                    logger.info(f"âœ… Weatherbit OK: {city}")
            except Exception as e:
                logger.warning(f"Weatherbit fallÃ³: {e}")
        
        if not forecasts:
            logger.error(f"âŒ Sin forecast para {city}")
            return None
        
        avg_temp = sum(f["temp"] for _, f in forecasts) / len(forecasts)
        high_temp = sum(f.get("high", avg_temp) for _, f in forecasts) / len(forecasts)
        low_temp = sum(f.get("low", avg_temp) for _, f in forecasts) / len(forecasts)
        
        temps = [f["temp"] for _, f in forecasts]
        spread = max(temps) - min(temps) if len(temps) > 1 else 0
        confidence = 2.0 if spread < 2 else (3.0 if spread < 4 else 4.0)
        
        result = {
            "avg": round(avg_temp, 1),
            "high": round(high_temp, 1),
            "low": round(low_temp, 1),
            "providers": len(forecasts),
            "spread": spread,
            "confidence": confidence
        }
        
        self.cache[cache_key] = {
            "time": datetime.now(timezone.utc),
            "data": result
        }
        
        return result
    
    def _fetch_tomorrowio(self, city: str, target_date: str) -> Optional[Dict]:
        coords = self.city_coords.get(city.lower())
        if not coords:
            logger.error(f"Sin coordenadas: {city}")
            return None
        
        try:
            params = {
                "location": f"{coords[0]},{coords[1]}",
                "fields": "temperature,temperatureMax,temperatureMin",
                "units": "imperial",
                "timesteps": "1d",
                "apikey": self.keys["tomorrowio"],
                "startTime": f"{target_date}T00:00:00Z",
                "endTime": f"{target_date}T23:59:59Z"
            }
            
            resp = self.session.get(CONFIG["tomorrowio_url"], params=params, timeout=15)
            resp.raise_for_status()
            data = resp.json()
            
            timelines = data.get("data", {}).get("timelines", [])
            if not timelines:
                return None
            
            intervals = timelines[0].get("intervals", [])
            if not intervals:
                return None
            
            vals = intervals[0].get("values", {})
            
            return {
                "temp": vals.get("temperature", 70),
                "high": vals.get("temperatureMax", 75),
                "low": vals.get("temperatureMin", 65),
            }
            
        except Exception as e:
            logger.error(f"Error Tomorrow.io: {e}")
            return None
    
    def _fetch_weatherbit(self, city: str, target_date: str) -> Optional[Dict]:
        try:
            city_query = self.weatherbit_cities.get(city.lower(), city)
            
            params = {
                "city": city_query,
                "key": self.keys["weatherbit"],
                "days": 16,
                "units": "I"
            }
            
            resp = self.session.get(CONFIG["weatherbit_url"], params=params, timeout=15)
            resp.raise_for_status()
            data = resp.json()
            
            for day in data.get("data", []):
                if day.get("valid_date") == target_date:
                    return {
                        "temp": day.get("temp", 70),
                        "high": day.get("max_temp", 75),
                        "low": day.get("min_temp", 65),
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"Error Weatherbit: {e}")
            return None

# === PARSING ===

def parse_outcome_index(label: str, outcomes_list: List[Dict]) -> int:
    label_clean = label.lower().strip()
    
    for i, out in enumerate(outcomes_list):
        out_name = out.get("name", out.get("label", "")).lower().strip()
        if out_name == label_clean or label_clean in out_name:
            return i
    
    return 0

def parse_temp_range(label: str) -> Optional[Dict]:
    label_lower = label.lower()
    
    patterns = [
        (r'(\d+)\s*-\s*(\d+)', 'range'),
        (r'above\s*(\d+)', 'above'),
        (r'over\s*(\d+)', 'above'),
        (r'below\s*(\d+)', 'below'),
        (r'under\s*(\d+)', 'below'),
        (r'exactly\s*(\d+)', 'exact'),
        (r'(\d+)\s*(?:Â°|degrees?)', 'exact')
    ]
    
    for pattern, ptype in patterns:
        match = re.search(pattern, label_lower)
        if match:
            if ptype == 'range':
                low, high = int(match.group(1)), int(match.group(2))
                return {"low": low, "high": high, "type": "range", "center": (low+high)/2}
            elif ptype == 'above':
                val = int(match.group(1))
                return {"low": val, "high": val+25, "type": "above", "center": val+5}
            elif ptype == 'below':
                val = int(match.group(1))
                return {"low": val-25, "high": val, "type": "below", "center": val-5}
            else:
                val = int(match.group(1))
                return {"low": val-2, "high": val+2, "type": "exact", "center": val}
    
    return None

# === GENERACIÃ“N DE SEÃ‘ALES ===

class SignalGenerator:
    def __init__(self):
        self.weather = WeatherAPI()
    
    def fetch_polymarket_weather(self) -> List[Dict]:
        try:
            logger.info("ğŸ” Buscando mercados...")
            params = {
                "active": "true",
                "liquidity": CONFIG["min_liquidity"],
                "limit": 500  # â† AUMENTADO
            }
            resp = requests.get(CONFIG["polymarket_gamma"], params=params, timeout=15)
            resp.raise_for_status()
            markets = resp.json()
            
            logger.info(f"   {len(markets)} mercados totales")
            
            weather_markets = []
            for m in markets:
                q = m.get("question", "").lower()
                
                # â† EXPANDIDO: MÃ¡s keywords
                if not any(kw in q for kw in CONFIG["weather_keywords"]):
                    continue
                
                city = None
                for c in CONFIG["cities"]:
                    if c.lower() in q:
                        city = c
                        break
                
                if not city:
                    continue
                
                date_match = re.search(
                    r'(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s*\d{1,2}',
                    q,
                    re.IGNORECASE
                )
                
                if date_match:
                    try:
                        parsed = dateparser.parse(
                            date_match.group(0), 
                            settings={'PREFER_DATES_FROM': 'future'}
                        )
                        if not parsed:
                            parsed = datetime.now(timezone.utc) + timedelta(days=1)
                    except:
                        parsed = datetime.now(timezone.utc) + timedelta(days=1)
                else:
                    parsed = datetime.now(timezone.utc) + timedelta(days=1)
                
                weather_markets.append({
                    "slug": m["slug"],
                    "condition_id": m.get("conditionId"),
                    "question": m["question"],
                    "city": city,
                    "outcomes": m.get("outcomes", []),
                    "liquidity": m.get("liquidity", 0),
                    "target_date": parsed.strftime("%Y-%m-%d"),
                    "end_date_iso": m.get("endDate")
                })
            
            logger.info(f"   âœ… {len(weather_markets)} mercados de clima")
            return weather_markets
            
        except Exception as e:
            logger.error(f"Error fetching markets: {e}")
            return []
    
    def calculate_edge(self, forecast: Dict, outcome: Dict, market: Dict) -> Optional[float]:
        try:
            market_prob = outcome.get("price", 0)
            if market_prob <= 0.01 or market_prob >= 0.99:
                return None
            
            label = outcome.get("name", outcome.get("label", ""))
            temp_range = parse_temp_range(label)
            if not temp_range:
                return None
            
            from statistics import NormalDist
            mean = forecast["avg"]
            std = forecast["confidence"]
            
            z_low = (temp_range["low"] - mean) / std
            z_high = (temp_range["high"] - mean) / std
            
            nd = NormalDist(0, 1)
            fair_prob = nd.cdf(z_high) - nd.cdf(z_low)
            
            if forecast.get("providers", 1) > 1 and forecast.get("spread", 0) > 3:
                fair_prob = 0.5 + (fair_prob - 0.5) * 0.8
            
            edge = (fair_prob - market_prob) / market_prob
            
            return edge
            
        except Exception as e:
            logger.debug(f"Error calculando edge: {e}")
            return None
    
    def generate_signals(self) -> List[Dict]:
        markets = self.fetch_polymarket_weather()
        signals = []
        
        for market in markets:
            try:
                if market.get("end_date_iso"):
                    end = datetime.fromisoformat(market["end_date_iso"].replace('Z', '+00:00'))
                else:
                    end = datetime.strptime(market["target_date"], "%Y-%m-%d")
                    end = end.replace(tzinfo=timezone.utc)
                
                hours_to_close = (end - datetime.now(timezone.utc)).total_seconds() / 3600
                if not (6 <= hours_to_close <= 24):
                    continue
            except:
                continue
            
            forecast = self.weather.get_forecast(market["city"], market["target_date"])
            if not forecast:
                continue
            
            for outcome in market["outcomes"]:
                price = outcome.get("price", 0)
                if not (0.05 <= price <= 0.95):
                    continue
                
                edge = self.calculate_edge(forecast, outcome, market)
                if edge is None or edge < CONFIG["min_edge"]:
                    continue
                
                outcome_index = parse_outcome_index(
                    outcome.get("name", outcome.get("label", "")),
                    market["outcomes"]
                )
                
                signals.append({
                    "market_slug": market["slug"],
                    "condition_id": market["condition_id"],
                    "question": market["question"],
                    "city": market["city"],
                    "outcome": outcome.get("name", outcome.get("label")),
                    "outcome_index": outcome_index,
                    "token_id": outcome.get("token_id"),
                    "price": price,
                    "edge": edge,
                    "forecast": forecast,
                    "hours_to_close": hours_to_close
                })
        
        signals.sort(key=lambda x: x["edge"], reverse=True)
        return signals

# === EJECUTOR ===

class TradeExecutor:
    def __init__(self):
        self.mode = os.getenv("TRADING_MODE", "paper")
    
    def execute(self, signal: Dict, stake: float) -> Tuple[bool, Optional[Position]]:
        if self.mode == "paper":
            return self._paper_trade(signal, stake)
        return self._live_trade(signal, stake)
    
    def _paper_trade(self, signal: Dict, stake: float) -> Tuple[bool, Optional[Position]]:
        pos = Position(
            position_id=f"paper_{int(time.time() * 1000)}",
            market_slug=signal["market_slug"],
            condition_id=signal["condition_id"],
            question=signal["question"],
            city=signal["city"],
            outcome=signal["outcome"],
            outcome_index=signal["outcome_index"],
            token_id=signal["token_id"],
            side="BUY",
            entry_price=signal["price"],
            shares=round(stake / signal["price"], 4),
            stake=stake,
            trade_type="core" if stake > 1.5 else "lottery",
            edge_at_entry=signal["edge"],
            entry_time=datetime.now(timezone.utc).isoformat(),
            target_date=(datetime.now(timezone.utc) + 
                        timedelta(hours=signal["hours_to_close"])).isoformat(),
            status="open",
            pnl_applied=False
        )
        
        logger.info(f"ğŸ“ PAPER: {signal['city']} | {signal['outcome'][:40]}... | "
                   f"${stake:.2f} @ {signal['price']:.0%} | Edge: {signal['edge']:.1%}")
        
        return True, pos
    
    def _live_trade(self, signal: Dict, stake: float) -> Tuple[bool, Optional[Position]]:
        logger.warning("Live trading requiere py-clob-client")
        return False, None

# === BOT PRINCIPAL ===

class SurvivalBot:
    def __init__(self):
        self.state = state_mgr.load_state()
        self.positions = state_mgr.load_positions()
        self.signals = SignalGenerator()
        self.executor = TradeExecutor()
        self.resolver = ResolutionEngine()
        
        self.state = check_daily_reset(self.state)
        
        open_pos = len([p for p in self.positions if p.status == "open"])
        logger.info(f"ğŸš€ TESTING MODE | Cash: ${self.state['cash']:.2f} | Open: {open_pos}")
        logger.info(f"   Config: edge>{CONFIG['min_edge']:.0%}, "
                   f"max{CONFIG['absolute_max_day']}trades/day, "
                   f"cooldown{CONFIG['cooldown_hours']}h")
    
    def calculate_position_size(self, edge: float, confidence: int) -> float:
        if edge < CONFIG["min_edge"]:
            return 0.0
        
        size = CONFIG["min_trade"]
        
        current_wr = self.state["wins"] / max(self.state["total_trades"], 1)
        if (edge > 0.25 and confidence >= 2 and  # â† MÃS PERMISIVO
            current_wr > 0.55 and                 # â† MÃS PERMISIVO
            self.state["consecutive_losses"] < 2): # â† MÃS PERMISIVO
            size = CONFIG["max_trade"]
        
        available = self.state["cash"] - self.state["exposed"]
        max_allowed = available * 0.25  # â† AUMENTADO: 25% (vs 20%)
        size = min(size, max_allowed)
        
        if self.state["consecutive_losses"] >= 2:
            size = CONFIG["min_trade"]
        
        return size if size >= CONFIG["min_trade"] else 0.0
    
    def can_trade(self) -> bool:
        if self.state["today_trades"] >= CONFIG["absolute_max_day"]:
            logger.info(f"â›” LÃ­mite diario: {self.state['today_trades']}/{CONFIG['absolute_max_day']}")
            return False
        
        if self.state["today_losses"] >= CONFIG["stop_loss_day"]:
            logger.info(f"ğŸ›‘ Stop loss: {self.state['today_losses']}/{CONFIG['stop_loss_day']}")
            return False
        
        if self.state["last_trade_time"]:
            last = datetime.fromisoformat(self.state["last_trade_time"])
            hours_since = (datetime.now(timezone.utc) - last).total_seconds() / 3600
            if hours_since < CONFIG["cooldown_hours"]:
                logger.info(f"â³ Cooldown: {CONFIG['cooldown_hours']-hours_since:.1f}h")
                return False
        
        available = self.state["cash"] - self.state["exposed"]
        if available < CONFIG["min_trade"]:
            logger.info(f"ğŸ’¸ Insuficiente: ${available:.2f}")
            return False
        
        return True
    
    def daily_report(self):
        wr = (self.state["wins"] / max(self.state["total_trades"], 1)) * 100
        today_wr = ((self.state["today_wins"] / max(self.state["today_trades"], 1) * 100)
                   if self.state["today_trades"] > 0 else 0)
        
        print("\n" + "="*60)
        print(f"ğŸ“Š {self.state['current_date']} | Cash: ${self.state['cash']:.2f}")
        print(f"ğŸ“ˆ Lifetime: {self.state['wins']}W/{self.state['losses']}L ({wr:.1f}%)")
        print(f"ğŸ¯ Hoy: {self.state['today_wins']}W/{self.state['today_losses']}L ({today_wr:.1f}%)")
        print(f"ğŸ’¼ Exposed: ${self.state['exposed']:.2f} | P&L: ${self.state['lifetime_pnl']:+.2f}")
        print(f"ğŸ“‰ Max Drawdown: ${self.state['max_drawdown']:.2f}")
        print(f"ğŸ² Trades hoy: {self.state['today_trades']}/{CONFIG['absolute_max_day']}")
        
        if self.state["cash"] < 15:  # â† ALERTA MÃS TEMPRANA
            print("ğŸš¨ CRÃTICO: Cash < $15")
        elif self.state["cash"] < 20:
            print("âš ï¸  ALERTA: Cash < $20")
        
        if wr < 50 and self.state["total_trades"] > 10:  # â† MÃS PERMISIVO
            print("ğŸš¨ ESTRATEGIA FALLIDA: WR < 50%")
        elif wr < 55 and self.state["total_trades"] > 15:
            print("âš ï¸  CUIDADO: WR < 55%")
        
        if wr > 60 and self.state["total_trades"] > 15:  # â† MÃS PERMISIVO
            print("âœ… BUENO: WR > 60%")
        if wr > 65 and self.state["total_trades"] > 20:
            print("âœ…âœ… LISTO PARA $100")
        
        print("="*60)
    
    def run(self):
        # 1. Resolver posiciones
        self.positions = self.resolver.check_all_positions(self.positions, self.state)
        
        # 2. Verificar si podemos trade
        if not self.can_trade():
            self.daily_report()
            state_mgr.save_state(self.state)
            state_mgr.save_positions(self.positions)
            return
        
        # 3. Generar seÃ±ales
        signals = self.signals.generate_signals()
        if not signals:
            logger.info("No hay seÃ±ales con edge suficiente")
            self.daily_report()
            return
        
        logger.info(f"ğŸ¯ {len(signals)} seÃ±ales con edge > {CONFIG['min_edge']:.0%}")
        if len(signals) > 0:
            logger.info(f"   Top: {signals[0]['city']} {signals[0]['outcome'][:25]}... "
                       f"@ {signals[0]['price']:.0%} (edge: {signals[0]['edge']:.1%})")
        
        # 4. Ejecutar mejor seÃ±al
        best = signals[0]
        stake = self.calculate_position_size(best["edge"], best["forecast"]["providers"])
        
        if stake <= 0:
            logger.info("âš ï¸ Stake: $0 (condiciones no cumplen)")
            self.daily_report()
            return
        
        success, position = self.executor.execute(best, stake)
        
        if success and position:
            self.positions.append(position)
            self.state["cash"] -= stake
            self.state["exposed"] += stake
            self.state["today_trades"] += 1
            self.state["total_trades"] += 1
            self.state["last_trade_time"] = datetime.now(timezone.utc).isoformat()
            
            self.state = update_drawdown(self.state)
            logger.info(f"âœ… Trade ejecutado: ${stake:.2f}")
        
        # 5. Guardar todo
        state_mgr.save_state(self.state)
        state_mgr.save_positions(self.positions)
        self.daily_report()

# === MAIN ===

def run_single_cycle():
    try:
        bot = SurvivalBot()
        bot.run()
        return True
    except Exception as e:
        logger.exception("Error en ciclo")
        return False

if __name__ == "__main__":
    import sys
    
    # Modo single run (default para testing)
    if len(sys.argv) > 1 and sys.argv[1] == "--once":
        logger.info("ğŸ”„ Modo: Single run (--once)")
        run_single_cycle()
    else:
        # Modo scheduler
        logger.info("ğŸ¤– MODO SCHEDULER - Testing agresivo")
        logger.info(f"   Intervalo: {CONFIG['run_interval_seconds']/60:.0f} minutos")
        logger.info("   Presiona Ctrl+C para detener")
        
        start_time = time.time()
        max_runtime = CONFIG["max_runtime_hours"] * 3600
        cycle_count = 0
        
        while True:
            cycle_count += 1
            logger.info(f"\n{'='*60}")
            logger.info(f"â° CICLO #{cycle_count} - {datetime.now(timezone.utc).strftime('%H:%M UTC')}")
            logger.info(f"{'='*60}")
            
            run_single_cycle()
            
            elapsed = time.time() - start_time
            if elapsed > max_runtime:
                logger.info("â° Tiempo mÃ¡ximo alcanzado. Reiniciar manualmente.")
                break
            
            logger.info(f"ğŸ˜´ Durmiendo {CONFIG['run_interval_seconds']/60:.0f} min...")
            time.sleep(CONFIG["run_interval_seconds"])
